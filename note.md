# AHC013 RECRUIT 日本橋ハーフマラソン 2022夏

## ツールのコマンド
- 入力データの生成（tools/ にて実行）
    ```
    cargo run --release --bin gen seeds.txt # 入力ファイルの生成, in/ に出力される 
    ```
- ビジュアライザの生成（tools/ にて実行）  
入力ファイルを in.txt、出力ファイルを out.txt とする
    ```
    cargo run --release --bin vis in.txt out.txt
    ```
## やること
- アイデアの実装（繋がってないコンピュータを適当な方向に移動して、ケーブルにあたれば繋ぐ。
- 結果計算・集計のシェルスクリプトを書く

## 2022.08.10 Wed (2日目)
- 正の点数を達成。各セルに対して下と右を見て、同じ種類であればつなげる。単純なもの。
    - 7,555
- 下と右とを見て、進めるだけ進んで、同じ種類であれば繋げる。
    - クロスするのはダメなので、繋いでいるセルには適当な数値を書き込むことにした。
    - 実装で少し手間取ったが、なんとかなった。
    - 提出待ち。
    - 26,263
        - 263位, トップのスコアの10%
- アイデア
    - 繋がっていないコンピュータで、いずれかの方向に伸ばしてみて同じ種類のコンピュータの「線」に当たれば、そこまで移動して繋げる
    - もしくは1つの方向にしか伸びていないコンピュータは、その方向に移動して合流させる
    - 繋ぐ方の出力用配列を初期化して、繋ぎ直す。
## 2022.08.11 Thu (3日目、祝日)
- シェルスクリプトの調整
    - 指定した回数分、ループでプログラムを回すようにできた。
    - 0000 ~ 9999 までの出力ファイルを生成。
    - 数字を0埋めするのは、 seq コマンドの -f オプションが使えた。下のコマンドをバッククォート (`) で囲って、for 文に渡せばよい。
        ```
        seq -f '%04g' 0 99
        for i in `seq -f '%04g' 0 99`
        do 
            echo $i
        done
        ```
    - 入力ファイルがデフォルトで 0099 までしかなかったので、 0999 までやろうとしたらエラー吐いた。
- アイデア：セルごとに縦横やるのではなく、縦全て、横全てみたいにやったらどうなる？
    - 特に変わらず。点数も同じ。
- ローカル用テスターの調整
    - 入力データの生成
        - README を見ながら、入力データの追加生成を試みた。
        - 途中でエラーが出て、入力データが生成されなかったので、その対応をやった。
            ```
            error[E0658]: use of unstable library feature 'int_abs_diff'
                --> src/lib.rs:199:15
                |
            199 |         if r0.abs_diff(r1) + c0.abs_diff(c1) != 1 {
                |               ^^^^^^^^
                |
                = note: see issue #89492 <https://github.com/rust-lang/rust/issues/89492> for more information

            error[E0658]: use of unstable library feature 'int_abs_diff'
                --> src/lib.rs:199:33
                |
            199 |         if r0.abs_diff(r1) + c0.abs_diff(c1) != 1 {
                |                                 ^^^^^^^^
                |
                = note: see issue #89492 <https://github.com/rust-lang/rust/issues/89492> for more information

            For more information about this error, try `rustc --explain E0658`.
            error: could not compile `tools` due to 2 previous errors
            ```
        - "use of unstable library feature" の部分で検索して、日本語のページで1番上に出たやつを参考に、以下のコマンドで Rust のバージョンをあげた。
            ```
            $ rustup install stable
            ..(中略)
                stable-x86_64-apple-darwin updated - rustc 1.62.1 (e092d0b6b 2022-07-16) (from rustc 1.58.1 (db9d1b20b 2022-01-20))
            $ rustc --version
            rustc 1.62.1 (e092d0b6b 2022-07-16)
            ```
        - これで、まったく同じコマンドをそのまま打ち直したら、今度は何事もなく終了して、無事入力ファイルが生成された。
    - ビジュアライザの生成
        - シェルスクリプトに追加。

## 2022.08.12 Fri (4日目)
- 何をやったか、何かをやったのかも覚えていない。
- ちまちまとシェルスクリプトをいじっていた気がする。
    - [このページ](https://qiita.com/gengar-094/items/e4918c3cab5c1d096751) が参考になった。

## 2022.08.13 Sat (day 5)
- 台風なので朝からやっている。
- サンプルコードを参考にして、実装し直した。
    - 「ランダムに動かす」の部分を省略したので、当然のごとく同じスコアが出た。[提出詳細](https://atcoder.jp/contests/ahc013/submissions/33973193)
- サンプルコードの「ランダムに動かす」を実装。
- 時間いっぱい始めから構成し直して、最もよかったものを出力する
    - Score : 42,138 [提出詳細](https://atcoder.jp/contests/ahc013/submissions/33975544)
    - まあ、大幅な改善ということはまずないだろうなと思っていたから、だいたい想定内。
    - Timer の構造体を作ったのは功績としては大きい。
- 焼きなましを考える前に、一旦シミュレーションを考えてみたい。
    - 繋がっていないコンピュータを動かして、同種のコンピュータを繋いでいるケーブル状に移動させて繋ぎ直す、というやつ。
    - Score : 56,188 [提出詳細](https://atcoder.jp/contests/ahc013/submissions/33978603)
    - もうちょい上がると思ってたが、こんなもんか。
    - やったこと
        - コンピュータにつながっているケーブルの数を管理。
        - コンピュータに繋がっているケーブルが0本で、上下左右いずれかに同じ種類のコンピュータを繋いでいるケーブルがあればそこまで移動
        - ケーブルを全て削除して、再度繋ぎ直す。
        - これを5回繰り返す。
        - 移動しすぎて「繋ぎきれなかった、、」となるのを防ぐため、残りの手数によっては処理を中断して繋ぐ。
    - 課題, アイデア
        - 平行に伸びる複数のケーブルが勿体無い。
        - 1方向にしかケーブルが繋がっていないコンピュータは、ケーブルの反対方向に伸ばしてもよいのでは？
        - 繋ぐか繋がないかに確率的な要素を入れてみる
        - 途中の調整でも、ランダムに移動してみる。

## 2022.08.14 Sun (day 6)
- ビームサーチを書いてみる
    - 正直そんなに伸びるとは思えないが、、、
    - 手順
        - 初期化
            - 探索対象配列を用意
            - 初期配置で、繋げるだけ繋ぎ、短s買う対象配列に入れる
        - 以下を、 z 回繰り返す （手数の半分くらい？ K * 50）
            - 次の配列を用意
            - 各状態から以下の操作を行い、次の配列に突っ込む（それぞれ x 通りくらい？）
                - ランダムに動かす（繋いでいるケーブルは、同種のコンピュータであれば動かせる）
                - ケーブルをリセット
                - 繋げるだけ繋いで評価する
            - 配列をソートする
            - 上から y 通りを残して消し、「次の配列」を探索対象配列として、次にいく
    - 必要な構造 (state)
        - MoveAction[] moves
        - int[][] field : moves 完了時点での場の状態
        - int score
        - int calc_score(state s)
    - 実装してみたが、バグが取れない。
        - 手元では動いているように見えるが、ビジュアライザでスコア計算すると 
            out of range やら illegal connect やらが出てきて、全て0点になっている。
        - おそらく、 field を渡したり受け取ったりしたときに、初期状態を渡せばいいのか、
            途中までで渡せばいいのかがわからなくなっている。
        - Result 構造体と Solver 構造体がごっちゃになっているのも良くなさそう
- 焼きなましを磨いたほうが良さそうか？
    - やるとしたら、サンプルの Solver::solve() の中で、何度か繰り返すときに、
        試す前の点数を計算しておいて、点数が上がれば採用し、上がらなければ切り戻す、
        というのをやることになる。
    - ランダムに移動するときに、効率よく動かせるセルを探すようにしたり、スコア計算を効率化したりするのも、
        効果がありそう。
        - スコアを計算するときに、 UnionFind でそれぞれの木のサイズを管理しておいて、
            接続時に木同士のサイズの積をスコアに加算することで、幾分かは高速化できる。
- AGC058 に出ようかな。

## 2022.08.15 Mon (day 7)
- 方向性を整理して、一旦、多点出発の焼きなましをやっていこうという感じになった。
    - 各状態からの遷移先を、採用/非採用だけではなく、
    いくつかの選択肢を出して、それを枝状に広げていきたい、という発想になって、
    これがビームサーチの考え方なのかもなと思った。
- 朝から少しずつ、実装のやり直しをしている。
    - 朝、始業前までで、 UnionFind を整理して、各木のサイズを出せるようにした。
    これで、スコア計算が効率化できるはず。
    - 夕方、ランダムに動かすメソッドと、ケーブルをリセットして繋ぎ直すメソッドを書いた。
    - 始めから構成するのを時間いっぱいやって、最良のものを提出する、というのもやった。
    - 詳しくは集計できていないけれど、体感ではループを回せる量（試せる量）が段違いに増えている。
- ここまでで一旦コミット。
    - 初期回をたくさん作るだけなら、サンプルコードとそんなに変わらないかも。
    - とはいえ、高速化の工夫は随所に入れられたので、それでよしとする。
- ここから焼きなまし
    - 「始めから構成する」の部分を、「手数が尽きるまで適当に動かして再接続する焼きなまし」
    に書き換えていく。
- 焼きなまし書けた！！！！！
    - 実装して、一応それっぽい動きにはなっているっぽくて、手元で12ケース回したら 100K を突破した！
    - 少しだけ温度管理して、手元で100ケース回してみたい。
    - 温度調整前に、とりあえず100ケース回してみたが、約97K で 100K に届かず。。。
- 集計スクリプトを修正
    - K ごとの集計だけだったが、 K, N の組み合わせごとでも平均を出せるようにしてみた。
- 多点出発の焼きなまし、温度調整して提出した。
    - Score : 95,107 [提出詳細](https://atcoder.jp/contests/ahc013/submissions/34073930)

## 2022.08.16 Tue (day 8)
- 最終日
- 散歩しながら、DFS でつながる箇所を探すだけでも早いのでは？と思った。
- 使っていない構造体を消すだけでも、多少は上がるかもしれない。
    - 毎回初期化する必要のない配列を、事前に生成した。